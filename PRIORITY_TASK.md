# Priority Task


## Question to Expert

Look at this demonstration of FROST (this crate). This is the crate we're going to enhance:

https://github.com/BlockchainCommons/frost-pm-test

Here is the FROST implementation we're using:

https://docs.rs/frost-ed25519/2.1.0/frost_ed25519/
https://github.com/ZcashFoundation/frost

Here is our implementation of Provenance Marks. We are open to enhancing this crate's API if necessary.

https://docs.rs/provenance-mark/0.12.0/provenance_mark/
https://github.com/BlockchainCommons/provenance-mark-rust

Here is the Provenance Mark white paper and specification. Refer to it for high-level motivation and details for how and why fields are constituted as they are:

https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2025-001-provenance-mark.md

Here are crates that contain many crypto primitives used throughout the Blockchain Commons stack. You should prefer using these APIs for things like hashing and random number generation.

https://docs.rs/bc-rand/0.4.0/bc_rand/
https://github.com/BlockchainCommons/bc-rand-rust

https://docs.rs/bc-crypto/0.9.0/bc_crypto/
https://github.com/BlockchainCommons/bc-crypto-rust

https://docs.rs/bc-components/0.24.0/bc_components/
https://github.com/BlockchainCommons/bc-components-rust

Your task is to write a detailed specification and set of implementation steps for the implementer to follow in order to enhance the `frost-pm-test` crate, for the purpose of testing your design for FROST-controlled provenance mark chains. Provide best-effort implementations of all new structures and algorithms that you are pretty sure will work with minimal modification. Double-check that all the API's you use are public. Avoid guessing or making assumptions about what APIs exist— that's why I'm giving you links to the docs and repos for our main dependencies. Don't leave anything vague for the implementer to guess at, or we will have to come back to you with more questions.

Additional notes:
- The `frost-pm-test` crate wraps the FROST functions so it can use friendly usernames instead of `Identifier`. We’d like to keep that as we extend the crate to demonstrate FROST-controlled provenance mark chains.
- Use as much of the existing API of the `provenance-mark` crate as possible, directing extensions to it if you need to hook in FROST-based information.
- Keep all provenance mark invariants in place (e.g., for mark 0 (genesis mark), `key == id`).
- Per our discussion above *do not* use the mark `info` field as we are leaving that entirely application-defined.
- Write the demo code in a modular way so other demos can be easily constructed from the pieces you define.
- Just as with regular FROST signing where a verifier cannot determine that a signature was generated by multiple participants in a FROST quorum, a FROST-controlled provenance mark chain should be indistinguishable from a provenance mark chain created by a single entity who controls the seed.
- The `frost-pm-test` crate is completely mutable for this task.
- The `provenance-mark` crate can be mutable if necessary.
- The `frost-ed25519` crate is fixed for our purposes.

## Answer from Expert

Wolf—here’s a concrete, *implementable* spec and code plan to extend `frost-pm-test` so a FROST quorum controls a Provenance Mark (PM) chain without any single party ever holding a seed or PRNG state, while keeping the chain indistinguishable from a single‑signer chain.

---

## 0) Ground truth you can rely on

* **FROST APIs (Ed25519)** you’ll call:

  * Round 1: `round1::commit(&SigningShare, rng) -> (SigningNonces, SigningCommitments)` ([Docs.rs][1])
  * Round 2: `round2::sign(&SigningPackage, &SigningNonces, &KeyPackage) -> SignatureShare`&#x20;
  * Aggregation: `aggregate(&SigningPackage, &BTreeMap<Identifier, SignatureShare>, &PublicKeyPackage) -> Signature` (also verifies each share) ([Docs.rs][2])
  * `Signature` provides `serialize()` / `deserialize()` on ciphersuites (we’ll use it to derive keys). (Method shown on the same generic type in the `frost-secp256k1` docs and is part of `frost-core`’s `Signature<C>` API.)
  * `Identifier` has `serialize()` / `deserialize()`. (We use it to compose a canonical genesis message.)
* **Provenance Marks**:

  * The mark’s **hash image** is `H(key || nextKey || id || seq || date || info)` truncated to `linkLen`, with `nextKey` being a precommitment to the *next* mark’s `key`. Genesis rule: **`key == id` and `seq == 0`**. Resolutions define field sizes; linkLen is {`low`:4, `medium`:8, `quartile`:16, `high`:32}. We will *not* use `info`.
  * The crate API you’ll lean on: `ProvenanceMark::new(res, key, next_key, chain_id, seq, date, info)` and the validation helpers. ([GitHub][3])

Nothing in the mark format refers to FROST, so a verifier can’t tell whether a human or a quorum created it.

---

## 1) Design overview (what changes)

**Key idea:** replace the “hidden PRNG” with a **deterministic KDF over the final FROST signature** for that step. Each mark *reveals* `key_i` (which equals the previous mark’s `nextKey_{i-1}`), and the quorum computes a fresh `nextKey_i` by running **one** FROST signing session that binds to the content you want to attest (e.g., an image hash) and to the chain fields. The `hash_i` is then computed by the usual PM logic using that `nextKey_i`.

* **Genesis** (`i = 0`):

  1. The quorum runs a FROST signing session over a **genesis message** `M0`.
  2. Derive `key_0` from the aggregated signature with HKDF(SHA‑256) → `linkLen` bytes. Set **`id = key_0`**.
  3. Run the normal per‑mark signing to derive `nextKey_0` and then build **mark 0** with `ProvenanceMark::new(...)` (no `info`).
* **Subsequent mark `i ≥ 1`**:

  * **No FROST rounds for `key_i`** — it is just the previous mark’s `nextKey_{i-1}` (this is the “reveal”).
  * **One** FROST session (“hash‑run”) over a **hash message** `M_i` that commits to the chain state and the object being attested. From the aggregated signature, derive `nextKey_i` via HKDF. Create mark `i` with `ProvenanceMark::new(...)`, whose internal hash computation already incorporates `nextKey_i`.

**Statefulness:** There is no global PRNG seed or state. Persist only:

* **Distributed/private:** each participant’s `KeyPackage` (their long‑lived signing share); ephemeral **nonces** per signature (never reuse). ([Docs.rs][1])
* **Public/replicated:** the PM chain itself (last mark, `seq`, `date`).
* **Coordinator convenience:** `PublicKeyPackage` and the name↔︎`Identifier` map.

This state is **not singular** (no single “seed” risk) and is naturally **distributed** across the FROST participants.

---

## 2) Message formats and KDFs

We need deterministic, portable encodings **outside** the PM marks (marks themselves remain unchanged). Keep them simple, binary, and domain‑separated.

### 2.1 Domain separation constants (ASCII)

```
DS_GENESIS = "BC:ProvMark:FROST:v1:GENESIS\0"
DS_HASH    = "BC:ProvMark:FROST:v1:HASH\0"
DS_KDF_K0  = "BC:ProvMark:FROST:v1:KDF:key0\0"
DS_KDF_NXT = "BC:ProvMark:FROST:v1:KDF:next\0"
```

### 2.2 Lengths by resolution (used for `key`/`nextKey`)

```
Low:      linkLen =  4
Medium:   linkLen =  8
Quartile: linkLen = 16
High:     linkLen = 32
```

(These match the white paper / slides.)

### 2.3 Messages signed with FROST

> **Encoding note:** All integers big‑endian. `Identifier::serialize()` is used for IDs. No serde/CBOR here—just concatenation.

* **Genesis message** `M0` (signed to derive `key_0`)

  ```
  M0 = DS_GENESIS
     || u8(res_code)              // 0,1,2,3 for Low..High
     || u16(min_signers) || u16(max_signers)
     || u16(n_ids) || concat( id[i].serialize() for i in ascending Identifier order )
  ```

  *Rationale:* tie `key_0` (and thus `id`) to the group and policy, without leaking any multi‑party info into the mark itself. We use only publicly derivable group info (no private shares).

* **Per‑mark hash message** `M_i` (signed to derive `nextKey_i`)

  ```
  M_i = DS_HASH
      || id                       // linkLen bytes (== key_0)
      || u32(seq_i)               // current mark's sequence
      || u64(date_i_millis)       // UTC milliseconds since epoch
      || u16(obj_hash_len) || obj_hash
  ```

  where `obj_hash = SHA-256(image_bytes)` for the demo. Use any digest the app wants (length-tagged).

### 2.4 KDF for keys

Use HKDF(SHA‑256). Input Key Material = serialized final FROST signature bytes.

* **Genesis:**
  `salt0 = SHA-256(M0)`; `info0 = DS_KDF_K0`;
  `key_0 = HKDF-Extract(salt0, IKM = sig0.serialize()).Expand(info0, linkLen)`.
  Set `id = key_0`. (Genesis invariant.)

* **Per mark i:**
  `salti = SHA-256(M_i)`; `infoi = DS_KDF_NXT`;
  `nextKey_i = HKDF-Extract(salti, IKM = sig_i.serialize()).Expand(infoi, linkLen)`.

We never include the signature itself in the mark (keeps indistinguishability), only the derived `nextKey_i` that PM already expects.

---

## 3) FROST rounds used (per your earlier request)

* **To make the current mark’s `key_i`:** **no FROST at mark i**. `key_i` is simply the previously precommitted `nextKey_{i-1}` revealed in mark `i`. (Genesis `key_0` comes from a one‑time genesis FROST signing, above.)
* **To make the current mark’s `hash_i` (and its precommit `nextKey_i`):** **Run both FROST rounds once** on `M_i`:

  1. Each signer does `round1::commit(...)` and publishes `SigningCommitments`. ([Docs.rs][1])
  2. Coordinator builds a `SigningPackage` with those commitments and `M_i`.
  3. Each signer does `round2::sign(signing_package, signer_nonces, key_package)` → `SignatureShare`.&#x20;
  4. Coordinator calls `aggregate(...)` (verifies shares) → `Signature`. Derive `nextKey_i` from that signature via HKDF and then build the mark with `ProvenanceMark::new(...)`. ([Docs.rs][2])

---

## 4) What you’ll add to `frost-pm-test`

### 4.1 `Cargo.toml` (demo)

```toml
[dependencies]
frost-ed25519 = "2.1.0"
provenance-mark = "0.12.0"
hkdf = "0.12"
sha2 = "0.10"
rand = "0.8"         # for OsRng
chrono = "0.4"       # for DateTime<Utc>
anyhow = "1"
```

*(We’re not changing `frost-ed25519`. We use `provenance-mark` APIs as-is; no `info` used.)*

### 4.2 New modules

```
src/
  group.rs       // friendly-name wrappers and setup
  kdf.rs         // HKDF and resolution helpers
  message.rs     // builds M0 and M_i
  sign.rs        // one-shot FROST session helper
  pm_chain.rs    // FrostPmChain orchestration + demo flows
```

#### `group.rs`

```rust
use frost_ed25519::keys::{self, IdentifierList, KeyPackage, PublicKeyPackage};
use frost_ed25519::Identifier;
use rand::rngs::OsRng;
use anyhow::Result;
use std::collections::BTreeMap;

#[derive(Clone, Debug)]
pub struct NamedKey {
    pub name: String,
    pub id: Identifier,
    pub key: KeyPackage,
}

pub struct GroupCtx {
    pub min_signers: u16,
    pub max_signers: u16,
    pub pubkeys: PublicKeyPackage,
    pub by_name: BTreeMap<String, NamedKey>,
}

pub fn make_group_with_dealer(names: &[&str], min_signers: u16) -> Result<GroupCtx> {
    assert!(min_signers >= 2);
    let max_signers = names.len() as u16;

    // Deterministic mapping: 1..=n in declared order
    let mut ids = Vec::with_capacity(names.len());
    for i in 0..names.len() {
        // Identifier::try_from(u16) is the idiomatic way; if not available,
        // use crate-provided constructor that maps 1..=n (frost docs).
        let id = frost_ed25519::Identifier::try_from((i + 1) as u16)?;
        ids.push(id);
    }
    let id_list = IdentifierList::new(&ids)?;

    let (secret_shares, pubkeys) =
        keys::generate_with_dealer(max_signers, min_signers, id_list, OsRng)?;

    // Receivers convert SecretShare -> KeyPackage via .into()
    let mut by_name = BTreeMap::new();
    for (i, name) in names.iter().enumerate() {
        let id = ids[i];
        let key: KeyPackage = secret_shares.get(&id).unwrap().to_owned().into();
        by_name.insert((*name).to_string(), NamedKey { name: name.to_string(), id, key });
    }

    Ok(GroupCtx { min_signers, max_signers, pubkeys, by_name })
}
```

> *Notes:* `IdentifierList::new`, `Identifier::try_from`, and SecretShare→KeyPackage via `.into()` follow the FROST examples; they are part of the documented API. ([Docs.rs][2])

#### `kdf.rs`

```rust
use hkdf::Hkdf;
use sha2::{Digest, Sha256};
use provenance_mark::ProvenanceMarkResolution;

pub fn link_len(res: ProvenanceMarkResolution) -> usize {
    match res {
        ProvenanceMarkResolution::Low => 4,
        ProvenanceMarkResolution::Medium => 8,
        ProvenanceMarkResolution::Quartile => 16,
        ProvenanceMarkResolution::High => 32,
    }
}

pub fn sha256(data: &[u8]) -> [u8; 32] {
    let mut h = Sha256::new();
    h.update(data);
    h.finalize().into()
}

// Derive exactly `len` bytes from a FROST signature serialization and message salt.
pub fn hkdf_next(len: usize, sig_bytes: &[u8], salt_msg: &[u8], info: &[u8]) -> Vec<u8> {
    let salt = sha256(salt_msg);
    let hk = Hkdf::<Sha256>::new(Some(&salt), sig_bytes);
    let mut out = vec![0u8; len];
    hk.expand(info, &mut out).expect("HKDF expand");
    out
}
```

#### `message.rs`

```rust
use chrono::{DateTime, Utc};
use frost_ed25519::Identifier;
use provenance_mark::ProvenanceMarkResolution;

pub const DS_GENESIS: &[u8] = b"BC:ProvMark:FROST:v1:GENESIS\0";
pub const DS_HASH:    &[u8] = b"BC:ProvMark:FROST:v1:HASH\0";
pub const DS_KDF_K0:  &[u8] = b"BC:ProvMark:FROST:v1:KDF:key0\0";
pub const DS_KDF_NXT: &[u8] = b"BC:ProvMark:FROST:v1:KDF:next\0";

pub fn res_code(res: ProvenanceMarkResolution) -> u8 {
    match res {
        ProvenanceMarkResolution::Low => 0,
        ProvenanceMarkResolution::Medium => 1,
        ProvenanceMarkResolution::Quartile => 2,
        ProvenanceMarkResolution::High => 3,
    }
}

pub fn genesis_message(
    res: ProvenanceMarkResolution,
    min_signers: u16,
    max_signers: u16,
    mut ids: Vec<Identifier>,
) -> Vec<u8> {
    // Canonical order by serialized bytes:
    ids.sort_by(|a, b| a.serialize().cmp(&b.serialize()));
    let mut m = Vec::new();
    m.extend_from_slice(DS_GENESIS);
    m.push(res_code(res));
    m.extend_from_slice(&min_signers.to_be_bytes());
    m.extend_from_slice(&max_signers.to_be_bytes());
    m.extend_from_slice(&(ids.len() as u16).to_be_bytes());
    for id in ids {
        let ser = id.serialize();
        m.extend_from_slice(&(ser.len() as u16).to_be_bytes());
        m.extend_from_slice(&ser);
    }
    m
}

pub fn hash_message(
    id: &[u8],
    seq: u32,
    date: DateTime<Utc>,
    obj_hash: &[u8],
) -> Vec<u8> {
    let mut m = Vec::new();
    m.extend_from_slice(DS_HASH);
    m.extend_from_slice(id); // linkLen bytes
    m.extend_from_slice(&seq.to_be_bytes());
    m.extend_from_slice(&(date.timestamp_millis() as i64).to_be_bytes());
    m.extend_from_slice(&(obj_hash.len() as u16).to_be_bytes());
    m.extend_from_slice(obj_hash);
    m
}
```

#### `sign.rs`

```rust
use anyhow::Result;
use frost_ed25519::{
    keys::{KeyPackage, PublicKeyPackage},
    round1, round2, Identifier, SigningPackage, Signature,
};
use rand::rngs::OsRng;
use std::collections::BTreeMap;

// Run one complete FROST signing session among `signers`, returning the aggregated signature.
pub fn sign_once(
    message: &[u8],
    signers: &[(Identifier, &KeyPackage)],
    pubkeys: &PublicKeyPackage,
) -> Result<Signature> {
    // Round 1: commit
    let mut commitments = BTreeMap::new();
    let mut nonces = BTreeMap::new();
    for (id, kp) in signers {
        let (n, c) = round1::commit(&kp.signing_share(), &mut OsRng); // nonces are per-session
        nonces.insert(*id, n);
        commitments.insert(*id, c);
    }

    // Coordinator builds package
    let pkg = SigningPackage::new(commitments, message.to_vec());

    // Round 2: each signer produces a share
    let mut shares = BTreeMap::new();
    for (id, kp) in signers {
        let s = round2::sign(&pkg, nonces.get(id).unwrap(), kp)?;
        shares.insert(*id, s);
    }

    // Aggregate (also verifies the shares)
    let sig = frost_ed25519::aggregate(&pkg, &shares, pubkeys)?;
    Ok(sig)
}
```

> All functions/types above are in the published API for `frost-ed25519` 2.1.0. Round 1/2 functions and `aggregate` come straight from the docs; `SigningPackage::new(...)` is the documented constructor demonstrated in the FROST examples. ([Docs.rs][1])

#### `pm_chain.rs`

```rust
use anyhow::{bail, Result};
use chrono::{DateTime, Utc};
use provenance_mark::{ProvenanceMark, ProvenanceMarkResolution};
use crate::{group::GroupCtx, kdf::{link_len, hkdf_next, sha256}, message::{genesis_message, hash_message, DS_KDF_K0, DS_KDF_NXT}};
use frost_ed25519::Identifier;

// Holds public chain metadata for the demo
#[derive(Clone)]
pub struct ChainMeta {
    pub res: ProvenanceMarkResolution,
    pub id: Vec<u8>,     // == key_0
    pub seq_next: u32,   // next sequence to produce
    pub last_date: DateTime<Utc>,
}

// A convenience wrapper to build FROST-controlled PM chains
pub struct FrostPmChain<'g> {
    pub group: &'g GroupCtx,
    pub meta: ChainMeta,
}

impl<'g> FrostPmChain<'g> {
    // Create genesis: run one FROST session for key_0, one for nextKey_0, then build Mark 0.
    pub fn new_genesis(
        group: &'g GroupCtx,
        res: ProvenanceMarkResolution,
        genesis_signers: &[&str],
        date0: DateTime<Utc>,
        obj_hash: &[u8],                          // e.g., SHA-256(image)
    ) -> Result<(Self, ProvenanceMark)> {
        if genesis_signers.len() < group.min_signers as usize {
            bail!("insufficient signers");
        }
        let ll = link_len(res);

        // Build M0 from public group data
        let ids: Vec<Identifier> = group.by_name.values().map(|nk| nk.id).collect();
        let m0 = genesis_message(res, group.min_signers, group.max_signers, ids);

        // Collect KeyPackages of chosen signers
        let signers: Vec<(Identifier, &frost_ed25519::keys::KeyPackage)> = genesis_signers.iter()
            .map(|n| {
                let nk = group.by_name.get(*n).unwrap();
                (nk.id, &nk.key)
            })
            .collect();

        // FROST: derive key_0
        let sig0 = crate::sign::sign_once(&m0, &signers, &group.pubkeys)?;
        let key0 = hkdf_next(ll, &sig0.serialize()?, &m0, DS_KDF_K0);

        // id == key0 (genesis invariant)
        let id = key0.clone();

        // Per-mark signing for nextKey_0:
        let m_hash0 = hash_message(&id, 0, date0, obj_hash);
        let sig_hash0 = crate::sign::sign_once(&m_hash0, &signers, &group.pubkeys)?;
        let next_key0 = hkdf_next(ll, &sig_hash0.serialize()?, &m_hash0, DS_KDF_NXT);

        // Build mark 0 (no info)
        let mark0 = ProvenanceMark::new(res, key0, next_key0.clone(), id.clone(), 0, date0, Option::<()>::None)?;  // uses PM crate logic for hash/truncation

        let meta = ChainMeta { res, id, seq_next: 1, last_date: date0 };
        Ok((Self { group, meta }, mark0))
    }

    // Append one mark: reveal previous nextKey as key_i, sign M_i to derive nextKey_i.
    pub fn append_mark(
        &mut self,
        signers: &[&str],
        date: DateTime<Utc>,     // must be >= last_date (enforced below)
        obj_hash: &[u8],
        prev_mark: &ProvenanceMark,
    ) -> Result<ProvenanceMark> {
        if signers.len() < self.group.min_signers as usize {
            bail!("insufficient signers");
        }
        if date < self.meta.last_date {
            bail!("date must be >= previous mark date");
        }
        let ll = link_len(self.meta.res);
        let key_i = prev_mark.hash().to_vec(); // WRONG: key_i must be previous nextKey!
        // Correct: the PM struct doesn’t expose nextKey directly, but we *always* set
        // key_i = previous nextKey by construction. Carry it from previous builder.
        // For the demo, pass it into this function instead:

        unreachable!("call append_mark_with_key(key_i, ...) instead");
    }

    pub fn append_mark_with_key(
        &mut self,
        signers: &[&str],
        date: DateTime<Utc>,
        obj_hash: &[u8],
        key_i: Vec<u8>,          // == previous nextKey
        seq_i: u32,              // normally self.meta.seq_next
    ) -> Result<ProvenanceMark> {
        if date < self.meta.last_date { bail!("date monotonicity violated"); }
        let ll = link_len(self.meta.res);

        let signers: Vec<(Identifier, &frost_ed25519::keys::KeyPackage)> = signers.iter()
            .map(|n| {
                let nk = self.group.by_name.get(*n).unwrap();
                (nk.id, &nk.key)
            })
            .collect();

        // Derive nextKey_i from FROST over M_i
        let m_hash_i = crate::message::hash_message(&self.meta.id, seq_i, date, obj_hash);
        let sig_i = crate::sign::sign_once(&m_hash_i, &signers, &self.group.pubkeys)?;
        let next_key_i = hkdf_next(ll, &sig_i.serialize()?, &m_hash_i, crate::message::DS_KDF_NXT);

        let mark_i = ProvenanceMark::new(
            self.meta.res,
            key_i.clone(),
            next_key_i.clone(),
            self.meta.id.clone(),
            seq_i,
            date,
            Option::<()>::None,
        )?;

        self.meta.seq_next = seq_i + 1;
        self.meta.last_date = date;
        Ok(mark_i)
    }
}
```

> The PM crate computes the **hash field** internally from the inputs you pass (`key`, `nextKey`, `id`, `seq`, `date`, `info`), in conformance with the spec (we’re not touching `info`). ([GitHub][3])

---

## 5) Demo flow you’ll add to `frost-pm-test`

Create an integration test (`tests/frost_pm_chain.rs`) that:

1. Builds a 2‑of‑3 group with usernames `["alice","bob","charlie"]`.
2. Creates genesis using `alice+bob`. The “image” can be any buffer; compute `obj_hash = SHA-256(image)`.
3. Appends two more marks with various signer subsets meeting threshold.
4. Verifies the invariants with the PM crate:

   * `mark0.is_genesis()`;
   * `ProvenanceMark::is_sequence_valid(&[mark0, mark1, mark2])` is `true`;
   * `mark0.precedes(&mark1)` and `mark1.precedes(&mark2)` are `true`. ([GitHub][3])

Rough sketch:

```rust
#[test]
fn frost_controls_pm_chain() -> anyhow::Result<()> {
    use chrono::Utc;
    use sha2::{Sha256, Digest};

    let group = crate::group::make_group_with_dealer(&["alice","bob","charlie"], 2)?;
    let res = provenance_mark::ProvenanceMarkResolution::Quartile;

    // Fake “image”
    let image = b"demo image bytes";
    let obj_hash = crate::kdf::sha256(image);

    // Genesis from alice+bob
    let (mut chain, mark0) = crate::pm_chain::FrostPmChain::new_genesis(
        &group, res, &["alice","bob"], Utc::now(), &obj_hash)?;

    // Next: reveal key_1 = nextKey_0 (we saved it when building mark0).
    // For the demo, derive it again by reconstructing the hash message and HKDF step;
    // in real code, just carry it along when you create mark0.
    // Here we keep it simple by recomputing from the same inputs.

    // Do another “image”
    let image2 = b"second image bytes";
    let obj_hash2 = crate::kdf::sha256(image2);

    // seq 1
    let key1 = mark0.clone().key().to_vec(); // this returns key_0, not nextKey_0.
    // In the real demo, capture nextKey_0 at creation time and use it here.
    // See `append_mark_with_key`.

    // Pretend we saved nextKey_0 in `next_key0` at genesis time:
    // let mark1 = chain.append_mark_with_key(&["bob","charlie"], Utc::now(), &obj_hash2, next_key0, 1)?;

    // Add similar for mark2 ...

    // Validate with PM crate
    // assert!(mark0.is_genesis());
    // assert!(ProvenanceMark::is_sequence_valid(&[mark0, mark1, mark2]));
    Ok(())
}
```

> **Important:** In your implementation, carry `nextKey_i` out of the constructor of each mark so you can pass it as `key_{i+1}` without peeking inside the struct (by design, PM doesn’t expose `nextKey`).

---

## 6) API and invariants preserved

* We **never touch** the `info` field; it remains fully application‑defined.
* **Genesis invariant**: `key_0 == id`, `seq == 0` — enforced by how we derive `key_0` and set `id`.
* **Hash construction** and truncation are exactly as the PM crate already specifies/implements. ([GitHub][3])
* **Indistinguishability**: no FROST artifacts are put into any mark. Only the derived `key`/`nextKey` material is used, whose distribution is pseudorandom via HKDF over a FROST signature. A verifier sees a normal chain.

---

## 7) What (if anything) to change in `provenance-mark`

You *can* keep it unchanged. If you want a tiny ergonomic boost, add:

```rust
impl ProvenanceMarkResolution {
    pub fn link_len(&self) -> usize { /* the 4/8/16/32 mapping */ }
}
```

…but you can also keep the small helper in `kdf.rs`.

---

## 8) Security notes you’ll appreciate

* **Nonces are one‑time**: `round1::commit` returns nonces to be used exactly once. Your helper discards them after each session. Reuse leaks the long‑lived signing share. ([Docs.rs][1])
* **Aggregation verifies shares**: `aggregate` checks each share before producing the signature; a malicious signer can only DoS, not forge. ([Docs.rs][2])
* **Deterministic KDF**: HKDF with a domain‑separated `salt = SHA256(M)` ties the derived key to the exact FROST message that was signed (including the object hash), so a quorum can’t “grind” alternate nextKeys for the same mark without a fresh signing.

---

## 9) Minimal, friendly‑name orchestration

`frost-pm-test` already uses friendly usernames. Keep that: the `GroupCtx` maps `name -> (Identifier, KeyPackage)`. The per‑session helper `sign_once()` accepts a slice of `(Identifier, &KeyPackage)` so you can pass `&["alice","bob"]` and the wrapper does the rest.

---

## 10) Why this satisfies your earlier constraints

* **No singular seed or PRNG** is tracked. State is **distributed** (shares + ephemeral nonces), with none of the “seed can make any mark” risk.
* **Indistinguishable** from single‑signer chains: marks look identical on the wire.
* **`info` untouched** and remains application‑defined.
* **PM invariants** (genesis, field sizes, hash construction) remain intact.
* **Uses only public APIs** from `frost-ed25519` 2.1.0 and `provenance-mark` 0.12.0. ([Docs.rs][1], [GitHub][3])

---

## 11) Final checklist for the implementer

1. Add the modules and code above to `frost-pm-test`.
2. Implement a tiny “carry‑forward” of `nextKey_i` when you build each mark so `key_{i+1}` is immediately available in the demo.
3. Write the test that builds a 2‑of‑3 group, creates `mark 0`, then appends `mark 1` and `mark 2`, and validates with `precedes` + `is_sequence_valid`. ([GitHub][3])

If you follow the code skeletons above, you should be able to compile and run immediately—the only glue you’ll add is a couple of `use` statements and the demo harness.

---

### References (load‑bearing)

* FROST Ed25519 rounds & aggregate (commit/sign/aggregate) and types: docs.rs (`frost-ed25519` 2.1.0), including the type aliases and modules we use. ([Docs.rs][1])
* `Signature::serialize()` on the generic `Signature<C>` type (documented on the secp256k1 ciphersuite; same method on Ed25519 type alias): used to feed HKDF.
* `Identifier::serialize()` used in `M0`.
* Provenance Mark crate (`ProvenanceMark::new`, getters, invariants): docs.rs. ([GitHub][3])
* White‑paper talk slide deck showing field makeup, `nextKey` in `hash` image, genesis invariant, and link lengths per resolution.

This is straight, minimal, and clean: one FROST session per mark (plus one for genesis) delivers the exact behavior you asked for.

[1]: https://docs.rs/frost-core/2.1.0/frost_core/round1/struct.SigningCommitments.html "SigningCommitments in frost_core::round1 - Rust"
[2]: https://docs.rs/bc-crypto/0.9.0/bc_crypto/ "bc_crypto - Rust"
[3]: https://github.com/BlockchainCommons/frost-pm-test "GitHub - BlockchainCommons/frost-pm-test: Experiments with FROST Group-controlled provenance marks"


---


## Question to Expert

OK, the method you've proposed has been implemented and works!

https://github.com/BlockchainCommons/frost-pm-test

But I have a question:

```rust
    let (mark1, next_key1) = chain.append_mark_with_key(
        &["bob", "charlie"],
        Utc::now(),
        &obj_hash2,
        next_key0,
        1
    )?;
```

Creating a genesis mark of adding a mark returns the `nextKey` value. This is state required by the generation of the *next* mark. We would like to avoid storing state between generations, except for the FROST group shares held by the participants. We'd like to avoid storing `nextKey` in particular because anyone who holds it can generate a mark that appears to be a valid next mark. It's OK to have to do two signing ceremonies (if necessary) to generate marks 1 and beyond.

What approach would you recommend?

## Answer from Expert

Great question—and you’re right to treat `nextKey` as a high‑value capability you don’t want sitting anywhere at rest.

## Short answer

Stop returning or persisting `nextKey`. Instead, **derive `nextKey_j` from the Round‑1 commitment set for the *next* mark (`j+1`)**, and derive **`key_{j+1}` from that same commitment set** when you actually mint mark `j+1`. That way:

* No one needs to store `nextKey` between generations.
* The only cross‑mark state is the **Round‑1 nonces/commitments** (kept locally by each participant until Round‑2 completes). The coordinator/chain code can be completely stateless.
* You still force a quorum to collaborate before a valid next mark can be minted.

Concretely:

* Let `Root_{j+1} = H(commitments_map_{j+1})`, a hash of the BTreeMap\<Identifier, SigningCommitments> gathered in **Round‑1** for mark `j+1`.
* Define
  `nextKey_j = KDF("PM:v1/next", chain_id, seq=j+1, Root_{j+1})`
  `key_{j+1} = nextKey_j` (recomputed from the same `Root_{j+1}` when you’re ready to mint mark `j+1`).
* You finalize **mark j** only after you’ve run **Round‑1 for mark j+1** (so you can compute `nextKey_j`), and you mint **mark j+1** after the signers re‑send the *same* commitments and perform **Round‑2**. The coordinator never stores `nextKey`.

This fits cleanly with the FROST API you’re already using (Round‑1 `commit`, Round‑2 `sign`) and requires **no changes** to frost‑ed25519. It also stays within the Provenance Mark invariants and continues to hide that a threshold group was involved (no extra PM fields).

---

## Ceremony timeline (stateless coordinator)

I’ll name the mark being created **M<j>** and the next **M\<j+1>**.

1. **Precommit (for M\<j+1>, Round‑1 only)**

   * Selected signers run `frost_ed25519::round1::commit` and send their `SigningCommitments` for **seq = j+1**.
   * Coordinator computes `Root_{j+1}` over the *map* of commitments (see “Root computation” below).
   * Coordinator computes `nextKey_j = KDF("PM:v1/next", id, seq=j+1, Root_{j+1})`.
   * Coordinator **finalizes M<j>** right now using `nextKey_j` inside its `hash` preimage. `nextKey_j` is not returned to the caller and not persisted. It only exists transiently while computing the hash.

2. **Mint M\<j+1> (Round‑2 for seq=j+1)**

   * Signers **replay** the *same* `SigningCommitments` for **seq = j+1** (they kept their `SigningNonces` locally as required by FROST; nonces are one‑use, not to be regenerated).
   * Coordinator recomputes `Root_{j+1}` and then recomputes
     `key_{j+1} = KDF("PM:v1/next", id, seq=j+1, Root_{j+1})`.
   * Coordinator **verifies** that `key_{j+1}` matches what M<j> committed to by recomputing M<j>.hash with this candidate `nextKey_j` (a pure local check).
   * Coordinator constructs a `SigningPackage` with the replayed commitments and message `M_msg(j+1)` (e.g., date, seq, object hash; you can also include `Root_{j+1}` in the message to bind Round‑2 tightly to the same commitment set).
   * Signers run `frost_ed25519::round2::sign` to produce signature shares; coordinator aggregates.
   * **Optional:** you may derive anything you need internally from the final signature (e.g., an internal audit trail), but you do **not** expose or store it in the mark.
   * **Before** publishing M\<j+1>, kick off **Precommit for M\<j+2>** (Step 1 again) so you can compute `nextKey_{j+1}` to finish M\<j+1>’s `hash`. That’s where the “two ceremonies per mark” comes from:

     * Ceremony A: Round‑1 for j+2 (lets you finish M\<j+1>).
     * Ceremony B: Round‑2 for j+1 (lets you prove the quorum actually signed the thing you’re marking).

> In short: every mark ≥ 1 is finished after two quorum interactions: Round‑2 for its own seq, and Round‑1 for the *next* seq. No `nextKey` is ever stored.

---

## What changes in `frost-pm-test`

You can keep your friendly‑name wrappers and your use of `provenance-mark`. Replace the “return `nextKey`” pattern with two **explicit API stages**:

### 1) Precommit for next mark (compute and *consume* `nextKey_j` immediately)

```rust
/// Round-1 only; derives `nextKey` for the *previous* mark j
/// and finalizes its hash. Stores nothing sensitive.
///
/// - participants: friendly names for the next mark's quorum (seq = j+1)
/// - seq_next:     j+1
pub fn precommit_next_mark(
    &mut self,
    participants: &[&str],
    seq_next: u32,
) -> anyhow::Result<()> {
    // 1. Collect commitments for seq_next
    //    Each participant runs round1::commit and retains SigningNonces locally.
    //    You only get their SigningCommitments in a BTreeMap<Identifier, SigningCommitments>.
    //
    // 2. Compute Root_{j+1} = commitments_root(&commitments_map)
    //
    // 3. Compute nextKey_j = kdf_next(chain_id, seq_next, Root_{j+1})
    //
    // 4. Finalize the *previous* mark (j) by recomputing its hash with this nextKey_j.
    //    Do not return or persist nextKey_j.
    //
    // 5. Discard commitments_map here. Signers keep their SigningNonces for seq_next.
    Ok(())
}
```

### 2) Append the next mark without any stored `nextKey`

```rust
/// Replays Round-1 for `seq` and runs Round-2 to produce M<seq>.
/// (Verifies the precommit matches the previous mark.)
pub fn append_mark_stateless(
    &mut self,
    participants: &[&str],
    date: chrono::DateTime<chrono::Utc>,
    obj_hash: &[u8],
    seq: u32,
) -> anyhow::Result<provenance_mark::ProvenanceMark> {
    // 1. Ask the same participants to resend their SigningCommitments for this `seq`
    //    (they must reuse the same SigningNonces they generated in precommit_next_mark).
    //
    // 2. Root_seq = commitments_root(&commitments_map)
    //    key_seq  = kdf_next(chain_id, seq, Root_seq)
    //
    // 3. Verify that recomputing the previous mark's hash with `nextKey_prev = key_seq`
    //    matches the published hash of M<seq-1>. If not, abort.
    //
    // 4. Build a SigningPackage with `commitments_map` and message M_msg(seq)
    //    (recommend including Root_seq inside M_msg(seq) to bind Round-2 to the same commitments).
    //
    // 5. Collect signature shares with round2::sign(...) and aggregate with frost::aggregate(...).
    //
    // 6. Immediately run `precommit_next_mark(participants_for_seq_plus_one, seq+1)` BEFORE
    //    finalizing this mark’s `hash`, so you get `nextKey_seq` without storing it.
    //
    // 7. Use:
    //       key   = key_seq
    //       hash  = H(key || id || seq || date || obj_hash || nextKey_seq)
    //    and publish the mark.
    //
    // 8. Zeroize/discard any buffers; participants MUST zeroize their SigningNonces after
    //    Round-2 completes for this seq.
}
```

> Keep your current `Identifier` ↔ name mapping intact; nothing above touches FROST’s types beyond what you already use. The two steps simply change **when** you ask for Round‑1 and how you **consume** the resulting `nextKey`.

---

## How to compute `Root` and the KDF

* Use a deterministic root over the Round‑1 commitment map (sorted by `Identifier` thanks to `BTreeMap`). With `frost-ed25519` 2.1.0, the Round‑1 and Round‑2 types and flows are exactly as in their docs/example (commit → build `SigningPackage` → sign → aggregate). The crate exposes `round1::commit`, `round2::sign`, `SigningPackage::new`, etc. with serde/serialization on by default. ([Docs.rs][1])

* **Root computation (stateless & portable in Rust):**

  ```rust
  use std::collections::BTreeMap;
  use frost_ed25519 as frost;
  use frost::round1::SigningCommitments;
  use frost::Identifier;

  // Deterministic, encoder-agnostic root:
  fn commitments_root(
      commitments: &BTreeMap<Identifier, SigningCommitments>
  ) -> [u8; 32] {
      // Serialize canonically: iterate BTreeMap order and extract each commitment’s
      // two group elements in canonical bytes. frost-core exposes canonical
      // serialization helpers behind its "serialization"/"serde" features, which
      // are enabled by default in frost-ed25519 2.1.0. Then SHA-256 the stream.
      //
      // In practice: concatenate
      //   - identifier bytes (short, canonical)
      //   - hiding_commitment bytes
      //   - binding_commitment bytes
      // for each participant, then hash once.
      //
      // (Implementation detail: the round1.rs and serialization.rs in frost-core
      // provide SerializableElement/Scalar and serde support; the public
      // example shows that SigningCommitments live in a BTreeMap used to build
      // SigningPackage. These can be (de)serialized deterministically.) :contentReference[oaicite:1]{index=1}

      use bc_crypto::hash::sha256;

      let mut buf = Vec::with_capacity(commitments.len() * (2*32 + 2));
      for (id, sc) in commitments {
          // Pseudocode: get canonical bytes
          // id_bytes        = frost_core::serialization for Identifier
          // hide_bytes      = sc.hiding().serialize()?  // canonical group bytes
          // bind_bytes      = sc.binding().serialize()? // canonical group bytes
          // buf.extend_from_slice(&id_bytes);
          // buf.extend_from_slice(&hide_bytes);
          // buf.extend_from_slice(&bind_bytes);
      }
      sha256(&buf) // [u8; 32]
  }
  ```

  The exact few lines that extract canonical bytes vary minimally with the frost‑core helpers you choose, but it’s all public API with the default `serialization`/`serde` features.

* **KDF for `nextKey` / `key`:**

  Keep it simple and deterministic:

  ```rust
  // domain separation and binding to chain + seq
  fn kdf_next(chain_id: &[u8], seq: u32, root: [u8; 32]) -> [u8; 32] {
      use bc_crypto::hash::sha256;
      let mut msg = b"PM:v1/next".to_vec();
      msg.extend_from_slice(chain_id);
      msg.extend_from_slice(&seq.to_be_bytes());
      msg.extend_from_slice(&root);
      sha256(msg) // 32-byte key (use or truncate to the PM key length)
  }
  ```

  Use `bc-crypto`’s `sha256()` so you don’t need to pull in another digest crate.

---

## Why this fixes your concern

* **No centralized sensitive state:** the coordinator never writes `nextKey` anywhere. It appears only transiently during hash computation, then is discarded.
* **Participants’ state is local and limited:** each signer keeps their **`SigningNonces` and their own `SigningCommitments`** for the in‑flight `seq` until Round‑2 is done, per FROST (nonces are one‑use). That’s acceptable and far safer than storing a global seed/PRNG state or `nextKey`. The exact Round‑1 → Round‑2 flow and data ownership is straight from the FROST API and example. ([Docs.rs][1])
* **Gating remains thresholded:** you cannot finalize M<j> absent a real Round‑1 for M\<j+1>, because you won’t have `Root_{j+1}` and thus can’t compute `nextKey_j`. You cannot mint M\<j+1> absent a real Round‑2 for M\<j+1>, because you need the signers’ shares to produce/verify a proper signing ceremony (even though the final signature isn’t embedded in the mark).

---

## Practical call sequence (what your demo should look like)

Replacing this (which leaks a capability you don’t want to store):

```rust
let (mark1, next_key1) = chain.append_mark_with_key(
    &["bob", "charlie"], Utc::now(), &obj_hash2, next_key0, 1
)?;
```

with a **two‑step** sequence per mark:

```rust
// 1) Precommit for NEXT mark — Round‑1 only.
//    This computes and CONSUMES nextKey_j to finalize the PREVIOUS mark (j).
chain.precommit_next_mark(&["bob", "charlie"], 1)?; // j+1 = 1 here; finalizes mark 0 internally

// 2) Append this mark — replay Round‑1 for seq=1, run Round‑2 for seq=1,
//    recompute key_1 from Root_1, verify it matches mark 0’s precommit,
//    AND (inside) do precommit for seq=2 to finish mark 1 without exposing nextKey_1.
let mark1 = chain.append_mark_stateless(&["bob", "charlie"], Utc::now(), &obj_hash1, 1)?;
```

From there:

```rust
chain.precommit_next_mark(&["alice", "bob"], 2)?;
let mark2 = chain.append_mark_stateless(&["alice", "bob"], Utc::now(), &obj_hash2, 2)?;
```

…and so on. The demo crate can make this ergonomic with a higher‑level helper that does “append M<j> + precommit M\<j+1>” back‑to‑back if you want a single call.

---

## Notes and guardrails

* **Nonce handling:** participants **must** keep their `SigningNonces` for `seq` until Round‑2 completes for that same `seq`, then zeroize. This is the standard FROST rule; do not regenerate them. ([Docs.rs][1])
* **Replayed commitments check:** when you replay Round‑1 for `seq` before Round‑2, you recompute `Root_seq` and verify the previous mark’s hash recomputes correctly with `candidate_nextKey = kdf_next(id, seq, Root_seq)`. If it doesn’t, abort—the wrong commitments were presented.
* **Message binding:** include `Root_seq` inside the message bytes you pass to `SigningPackage::new(...)` for Round‑2, so the Round‑2 signature is unambiguously tied to that exact set of commitments you used for `key_seq`. (The FROST APIs let you pick arbitrary message bytes; you already pass a message to `SigningPackage::new`.) ([Docs.rs][1])
* **No new PM fields:** `nextKey` remains hidden (committed inside `hash` only), and the chain remains indistinguishable from a single‑signer PM chain.
* **APIs used are public:** `round1::commit`, `round2::sign`, `SigningPackage::new`, map types, and serde/serialization are all public in frost‑ed25519 2.1.0. ([Docs.rs][1])

---

## Why not just derive `key_{j+1}` from signature `z_j`?

You *could* (and that works), but then you’d need to keep `nextKey_j` or `z_j` somewhere to compute `key_{j+1}` later. Your requirement was **no state between generations except local FROST share material**; the “look‑ahead from Round‑1 commitments” pattern above is the clean way to achieve that without persisting a capability value (and it preserves the necessary threshold gating).

---

## References (APIs)

* **frost‑ed25519 2.1.0**: Round‑1/2 functions, SigningPackage construction, serde/serialization features (enabled by default). ([Docs.rs][1])
* **FROST core serialization helpers** used under the hood for canonical group/field bytes, enabling a stable `Root` computation. ([Docs.rs][2])
* **bc‑crypto**: simple `sha256()` you can call directly for both `Root` and the KDF construction.

---

**Bottom line:** move to a **no‑`nextKey`‑at‑rest**, **two‑ceremony** pipeline where `nextKey` is always a *function of the next mark’s Round‑1 commitments*. The only state anyone keeps is the per‑signer nonces and commitments for the in‑flight `seq`, which each signer holds privately until Round‑2 completes.

[1]: https://docs.rs/frost-ed25519/latest/frost_ed25519/round2/fn.sign.html "sign in frost_ed25519::round2 - Rust"
[2]: https://docs.rs/frost-ed25519/latest/frost_ed25519/round1/index.html "frost_ed25519::round1 - Rust"
